{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../src/parse.ts"],"names":[],"mappings":"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","sourcesContent":["// parse a single path portion\n\nimport { MinimatchOptions } from '.'\nimport { parseClass } from './brace-expressions'\n\n// classes [] are handled by the parseClass method\n// for positive extglobs, we sub-parse the contents, and combine,\n// with the appropriate regexp close.\n// for negative extglobs, we sub-parse the contents, but then\n// have to include the rest of the pattern, then the parent, etc.,\n// as the thing that cannot be because RegExp negative lookaheads\n// are different from globs.\n//\n// So for example:\n// a@(i|w!(x|y)z|j)b => ^a(i|w((!?(x|y)zb).*)z|j)b$\n//   1   2 3   4 5 6      1   2    3   46      5 6\n//\n// Assembling the extglob requires not just the negated patterns themselves,\n// but also anything following the negative patterns up to the boundary\n// of the current pattern, plus anything following in the parent pattern.\n//\n//\n// So, first, we parse the string into an AST of extglobs, without turning\n// anything into regexps yet.\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y']}, 'z'], ['j']]}, 'b']\n//\n// Then, for all the negative extglobs, we append whatever comes after in\n// each parent as their tail\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y'], 'z', 'b'}, 'z'], ['j']]}, 'b']\n//\n// Lastly, we turn each of these pieces into a regexp, and join\n//\n//                                 v----- .* because there's more following,\n//                                 v    v  otherwise, .+ because it must be\n//                                 v    v  *something* there.\n// ['^a', {@ ['i', 'w(?:(!?(?:x|y).*zb$).*)z', 'j' ]}, 'b$']\n//   copy what follows into here--^^^^^\n// ['^a', '(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)', 'b$']\n// ['^a(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)b$']\n\ntype ExtglobType = '!' | '?' | '+' | '*' | '@'\nconst types = new Set<ExtglobType>(['!', '?', '+', '*', '@'])\nconst isExtglobType = (c: string): c is ExtglobType =>\n  types.has(c as ExtglobType)\n\n// characters that indicate a start of pattern needs the \"no dots\" bit\nconst addPatternStart = new Set(['[', '.'])\nconst justDots = new Set(['..', '.'])\nconst reSpecials = new Set('().*{}+?[]^$\\\\!')\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\nexport class AST {\n  type: ExtglobType | null\n  readonly #root: AST\n\n  #parts: (string | AST)[] = []\n  readonly #parent?: AST\n  readonly #parentIndex: number\n  #negs: AST[]\n  #filledNegs: boolean = false\n  #options: MinimatchOptions\n\n  constructor(\n    type: ExtglobType | null,\n    parent?: AST,\n    options: MinimatchOptions = {}\n  ) {\n    this.type = type\n    this.#parent = parent\n    this.#root = this.#parent ? this.#parent.#root : this\n    this.#options = this.#root === this ? options : this.#root.#options\n    this.#negs = this.#root === this ? [] : this.#root.#negs\n    if (type === '!' && !this.#root.#filledNegs) this.#negs.push(this)\n    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0\n  }\n\n  fillNegs() {\n    if (this !== this.#root) {\n      this.#root.fillNegs()\n      return this\n    }\n    if (this.#filledNegs) return this\n    this.#filledNegs = true\n    let n: AST | undefined\n    while ((n = this.#negs.pop())) {\n      if (n.type !== '!') continue\n      // walk up the tree, appending everthing that comes AFTER parentIndex\n      let p: AST | undefined = n\n      let pp = p.#parent\n      while (pp) {\n        for (\n          let i = p.#parentIndex + 1;\n          !pp.type && i < pp.#parts.length;\n          i++\n        ) {\n          for (const part of n.#parts) {\n            /* c8 ignore start */\n            if (typeof part === 'string') {\n              throw new Error('string part in extglob AST??')\n            }\n            /* c8 ignore stop */\n            part.copyIn(pp.#parts[i])\n          }\n        }\n        p = pp\n        pp = p.#parent\n      }\n    }\n    return this\n  }\n\n  push(...parts: (string | AST)[]) {\n    for (const p of parts) {\n      if (p === '') continue\n      /* c8 ignore start */\n      if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n        throw new Error('invalid part: ' + p)\n      }\n      /* c8 ignore stop */\n      this.#parts.push(p)\n    }\n  }\n\n  toJSON() {\n    const ret: any[] =\n      this.type === null ? this.#parts.slice() : [this.type, ...this.#parts]\n    if (this.isStart() && !this.type) ret.unshift([])\n    if (\n      this.isEnd() &&\n      (this === this.#root ||\n        (this.#root.#filledNegs && this.#parent?.type === '!'))\n    ) {\n      ret.push({})\n    }\n    return ret\n  }\n\n  isStart(): boolean {\n    if (this.#root === this) return true\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!this.#parent?.isStart()) return false\n    return this.#parentIndex === 0\n  }\n\n  isEnd(): boolean {\n    if (this.#root === this) return true\n    if (this.#parent?.type === '!') return true\n    if (!this.#parent?.isEnd()) return false\n    if (!this.type) return this.#parent?.isEnd()\n    return (\n      this.#parentIndex === (this.#parent ? this.#parent.#parts.length : 0) - 1\n    )\n  }\n\n  copyIn(part: AST | string) {\n    if (typeof part === 'string') this.push(part)\n    else this.push(part.clone(this))\n  }\n\n  clone(parent: AST) {\n    const c = new AST(this.type, parent)\n    for (const p of this.#parts) {\n      c.copyIn(p)\n    }\n    return c\n  }\n\n  static #parseAST(\n    str: string,\n    ast: AST,\n    pos: number,\n    opt: MinimatchOptions\n  ): number {\n    let escaping = false\n    if (ast.type === null) {\n      // outside of a extglob, append until we find a start\n      let i = pos\n      let acc = ''\n      while (i < str.length) {\n        const c = str.charAt(i++)\n        // still accumulate escapes at this point, but we do ignore\n        // starts that are escaped\n        if (escaping || c === '\\\\') {\n          escaping = !escaping\n          acc += c\n          continue\n        }\n        if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n          ast.push(acc)\n          acc = ''\n          const ext = new AST(c, ast)\n          i = AST.#parseAST(str, ext, i, opt)\n          ast.push(ext)\n          continue\n        }\n        acc += c\n      }\n      ast.push(acc)\n      return i\n    }\n\n    // some kind of extglob, pos is at the (\n    // find the next | or )\n    let i = pos + 1\n    let part = new AST(null, ast)\n    const parts: AST[] = []\n    let acc = ''\n    while (i < str.length) {\n      const c = str.charAt(i++)\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping\n        acc += c\n        continue\n      }\n      if (isExtglobType(c) && str.charAt(i) === '(') {\n        part.push(acc)\n        acc = ''\n        const ext = new AST(c, part)\n        part.push(ext)\n        i = AST.#parseAST(str, ext, i, opt)\n        continue\n      }\n      if (c === '|') {\n        part.push(acc)\n        acc = ''\n        parts.push(part)\n        part = new AST(null, ast)\n        continue\n      }\n      if (c === ')') {\n        part.push(acc)\n        acc = ''\n        ast.push(...parts, part)\n        return i\n      }\n      acc += c\n    }\n\n    // if we got here, it was a malformed extglob! not an extglob, but\n    // maybe something else in there.\n    ast.type = null\n    ast.#parts = [str.substring(pos)]\n    return i\n  }\n\n  static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n    const ast = new AST(null, undefined, options)\n    AST.#parseAST(pattern, ast, 0, options)\n    console.log('parsed', pattern, JSON.stringify(ast))\n    return ast\n  }\n\n  toRegExpSource(): string {\n    if (this.#root === this) this.fillNegs()\n    if (!this.type) {\n      const src = this.#parts\n        .map(p => {\n          if (typeof p === 'string') return AST.#parseGlob(p, this.#options)\n          else return p.toRegExpSource()\n        })\n        .join('')\n      let start = ''\n      if (this.isStart() && typeof this.#parts[0] === 'string') {\n        // '.' and '..' cannot match unless the pattern is that exactly\n        const dotTravAllowed =\n          this.#parts.length === 1 && justDots.has(this.#parts[0])\n        if (dotTravAllowed) {\n          start = '(?:^|\\\\/)'\n        } else {\n          const dotsAllowed =\n            this.#options.dot ||\n            // no need to prevent dots if it can't match a dot, or if a sub-pattern\n            // will be preventing it anyway.\n            !addPatternStart.has(src.charAt(0))\n          start = dotsAllowed ? '(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))' : '(?!\\\\.)'\n        }\n      }\n      let end = ''\n      if (\n        this.isEnd() &&\n        (this === this.#root ||\n          (this.#root.#filledNegs && this.#parent?.type === '!'))\n      ) {\n        end = '(?:$|\\\\/)'\n      }\n      return start + src + end\n    }\n\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:'\n    const body = this.#parts\n      .map(p => {\n        /* c8 ignore start */\n        if (typeof p === 'string') {\n          throw new Error('string type in extglob ast??')\n        }\n        /* c8 ignore stop */\n        return p.toRegExpSource()\n      })\n      .join('|')\n    const close =\n      this.type === '!'\n        ? '))[^/]*?)'\n        : this.type === '@'\n        ? ')'\n        : `)${this.type}`\n    return start + body + close\n  }\n\n  static #parseGlob(glob: string, options: MinimatchOptions): string {\n    let escaping = false\n    let re = ''\n    let uflag = false\n    let hasMagic = false\n    for (let i = 0; i < glob.length; i++) {\n      const c = glob.charAt(i)\n      if (escaping) {\n        escaping = false\n        re += (reSpecials.has(c) ? '\\\\' : '') + c\n        continue\n      }\n      if (c === '\\\\') {\n        if (i === glob.length - 1) {\n          re += '\\\\\\\\'\n        } else {\n          escaping = true\n        }\n        continue\n      }\n      if (c === '[') {\n        const [src, needUflag, consumed, magic] = parseClass(glob, i)\n        if (consumed) {\n          re += src\n          uflag = uflag || needUflag\n          i += consumed - 1\n          hasMagic = hasMagic || magic\n          continue\n        }\n      }\n      if (c === '*') {\n        re += star\n        hasMagic = true\n        continue\n      }\n      if (c === '?') {\n        re += qmark\n        hasMagic = true\n        continue\n      }\n      re += regExpEscape(c)\n    }\n    return re\n  }\n}\n\nconst pattern = 'a@(i|w!(x|y)z+(l|m)|j)'\nconst ast = AST.fromGlob(pattern).fillNegs()\nconsole.log('negged', pattern, JSON.stringify(ast))\nconsole.log('to re src', pattern, ast.toRegExpSource())\n\n// // the type (exttype or null for strings), and array of children tokens\n//\n// // append everything after a negative extglob to each of the parts\n// // of the negative extglob node.  So, eg, [a, [!, x, y], z]\n//\n// //\n// //\n// //\n// //\n//\n// const globUnescape = (s: string) => s.replace(/\\\\(.)/g, '$1')\n// const regExpEscape = (s: string) =>\n//   s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n//\n// // \"abc\" -> { a:true, b:true, c:true }\n// const charSet = (s: string) =>\n//   s.split('').reduce((set: { [k: string]: boolean }, c) => {\n//     set[c] = true\n//     return set\n//   }, {})\n//\n// // characters that need to be escaped in RegExp.\n// const reSpecials = charSet('().*{}+?[]^$\\\\!')\n//\n// // characters that indicate we have to add the pattern start\n// const addPatternStartSet = charSet('[.(')\n//\n// // any single thing other than /\n// // don't need to escape / when using new RegExp()\n// const qmark = '[^/]'\n//\n// // * => any number of characters\n// const star = qmark + '*?'\n//\n// // TODO: take an offset and length, so we can sub-parse the extglobs\n// const parse = (\n//   options: MinimatchOptions,\n//   pattern: string,\n//   debug: (...a: any[]) => void\n// ): false | string => {\n//   assertValidPattern(pattern)\n//\n//   if (pattern === '') return ''\n//\n//   let re = ''\n//   let hasMagic = false\n//   let escaping = false\n//   // ? => one single character\n//   let uflag = false\n//\n//   // . and .. never match anything that doesn't start with .,\n//   // even when options.dot is set.  However, if the pattern\n//   // starts with ., then traversal patterns can match.\n//   let dotTravAllowed = pattern.charAt(0) === '.'\n//   let dotFileAllowed = options.dot || dotTravAllowed\n//   const patternStart = () =>\n//     dotTravAllowed\n//       ? ''\n//       : dotFileAllowed\n//       ? '(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))'\n//       : '(?!\\\\.)'\n//   const subPatternStart = (p: string) =>\n//     p.charAt(0) === '.'\n//       ? ''\n//       : options.dot\n//       ? '(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))'\n//       : '(?!\\\\.)'\n//\n//   const clearStateChar = () => {\n//     if (stateChar) {\n//       // we had some state-tracking character\n//       // that wasn't consumed by this pass.\n//       switch (stateChar) {\n//         case '*':\n//           re += star\n//           hasMagic = true\n//           break\n//         case '?':\n//           re += qmark\n//           hasMagic = true\n//           break\n//         default:\n//           re += '\\\\' + stateChar\n//           break\n//       }\n//       debug('clearStateChar %j %j', stateChar, re)\n//       stateChar = false\n//     }\n//   }\n//\n//   for (\n//     let i = 0, c: string;\n//     i < pattern.length && (c = pattern.charAt(i));\n//     i++\n//   ) {\n//     debug('%s\\t%s %s %j', pattern, i, re, c)\n//\n//     // skip over any that are escaped.\n//     if (escaping) {\n//       // completely not allowed, even escaped.\n//       // should be impossible.\n//       /* c8 ignore start */\n//       if (c === '/') {\n//         return false\n//       }\n//       /* c8 ignore stop */\n//\n//       if (reSpecials[c]) {\n//         re += '\\\\'\n//       }\n//       re += c\n//       escaping = false\n//       continue\n//     }\n//\n//     switch (c) {\n//       // Should already be path-split by now.\n//       /* c8 ignore start */\n//       case '/': {\n//         return false\n//       }\n//       /* c8 ignore stop */\n//\n//       case '\\\\':\n//         clearStateChar()\n//         escaping = true\n//         continue\n//\n//       // the various stateChar values\n//       // for the \"extglob\" stuff.\n//       case '?':\n//       case '*':\n//       case '+':\n//       case '@':\n//       case '!':\n//         debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n//\n//         // if we already have a stateChar, then it means\n//         // that there was something like ** or +? in there.\n//         // Handle the stateChar, then proceed with this one.\n//         debug('call clearStateChar %j', stateChar)\n//         clearStateChar()\n//         stateChar = c\n//         // if extglob is disabled, then +(asdf|foo) isn't a thing.\n//         // just clear the statechar *now*, rather than even diving into\n//         // the patternList stuff.\n//         if (options.noext) clearStateChar()\n//         continue\n//\n//       case '(': {\n//         if (!stateChar) {\n//           re += '\\\\('\n//           continue\n//         }\n//\n//         const plEntry: PatternListEntry = {\n//           type: stateChar,\n//           start: i - 1,\n//           reStart: re.length,\n//           open: plTypes[stateChar].open,\n//           close: plTypes[stateChar].close,\n//         }\n//         debug(pattern, '\\t', plEntry)\n//         patternListStack.push(plEntry)\n//         // negation is (?:(?!(?:js)(?:<rest>))[^/]*)\n//         re += plEntry.open\n//         // next entry starts with a dot maybe?\n//         if (plEntry.start === 0 && plEntry.type !== '!') {\n//           dotTravAllowed = true\n//           re += subPatternStart(pattern.slice(i + 1))\n//         }\n//         debug('plType %j %j', stateChar, re)\n//         stateChar = false\n//         continue\n//       }\n//\n//       case ')': {\n//         const plEntry = patternListStack[patternListStack.length - 1]\n//         if (!plEntry) {\n//           re += '\\\\)'\n//           continue\n//         }\n//         patternListStack.pop()\n//\n//         // closing an extglob\n//         clearStateChar()\n//         hasMagic = true\n//         pl = plEntry\n//         // negation is (?:(?!js)[^/]*)\n//         // The others are (?:<pattern>)<type>\n//         re += pl.close\n//         if (pl.type === '!') {\n//           negativeLists.push(Object.assign(pl, { reEnd: re.length }))\n//         }\n//         continue\n//       }\n//\n//       case '|': {\n//         const plEntry = patternListStack[patternListStack.length - 1]\n//         if (!plEntry) {\n//           re += '\\\\|'\n//           continue\n//         }\n//\n//         clearStateChar()\n//         re += '|'\n//         // next subpattern can start with a dot?\n//         if (plEntry.start === 0 && plEntry.type !== '!') {\n//           dotTravAllowed = true\n//           re += subPatternStart(pattern.slice(i + 1))\n//         }\n//         continue\n//       }\n//\n//       // these are mostly the same in regexp and glob\n//       case '[':\n//         // swallow any state-tracking char before the [\n//         clearStateChar()\n//         const [src, needUflag, consumed, magic] = parseClass(pattern, i)\n//         if (consumed) {\n//           re += src\n//           uflag = uflag || needUflag\n//           i += consumed - 1\n//           hasMagic = hasMagic || magic\n//         } else {\n//           re += '\\\\['\n//         }\n//         continue\n//\n//       case ']':\n//         re += '\\\\' + c\n//         continue\n//\n//       default:\n//         // swallow any state char that wasn't consumed\n//         clearStateChar()\n//\n//         re += regExpEscape(c)\n//         break\n//     } // switch\n//   } // for\n//\n//   // handle the case where we had a +( thing at the *end*\n//   // of the pattern.\n//   // each pattern list stack adds 3 chars, and we need to go through\n//   // and escape any | chars that were passed through as-is for the regexp.\n//   // Go through and escape them, taking care not to double-escape any\n//   // | chars that were already escaped.\n//   for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n//     let tail: string\n//     tail = re.slice(pl.reStart + pl.open.length)\n//     debug(pattern, 'setting tail', re, pl)\n//     // maybe some even number of \\, then maybe 1 \\, followed by a |\n//     tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, (_, $1, $2) => {\n//       if (!$2) {\n//         // the | isn't already escaped, so escape it.\n//         $2 = '\\\\'\n//         // should already be done\n//         /* c8 ignore start */\n//       }\n//       /* c8 ignore stop */\n//\n//       // need to escape all those slashes *again*, without escaping the\n//       // one that we need for escaping the | character.  As it works out,\n//       // escaping an even number of slashes can be done by simply repeating\n//       // it exactly after itself.  That's why this trick works.\n//       //\n//       // I am sorry that you have to see this.\n//       return $1 + $1 + $2 + '|'\n//     })\n//\n//     debug('tail=%j\\n   %s', tail, tail, pl, re)\n//     const t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\\\' + pl.type\n//\n//     hasMagic = true\n//     re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n//   }\n//\n//   // handle trailing things that only matter at the very end.\n//   clearStateChar()\n//   if (escaping) {\n//     // trailing \\\\\n//     re += '\\\\\\\\'\n//   }\n//\n//   // only need to apply the nodot start if the re starts with\n//   // something that could conceivably capture a dot\n//   const addPatternStart = addPatternStartSet[re.charAt(0)]\n//\n//   // Hack to work around lack of negative lookbehind in JS\n//   // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n//   // like 'a.xyz.yz' doesn't match.  So, the first negative\n//   // lookahead, has to look ALL the way ahead, to the end of\n//   // the pattern.\n//   for (let n = negativeLists.length - 1; n > -1; n--) {\n//     const nl = negativeLists[n]\n//\n//     const nlBefore = re.slice(0, nl.reStart)\n//     const nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n//     let nlAfter = re.slice(nl.reEnd)\n//     const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter\n//\n//     // Handle nested stuff like *(*.js|!(*.json)), where open parens\n//     // mean that we should *not* include the ) in the bit that is considered\n//     // \"after\" the negated section.\n//     const closeParensBefore = nlBefore.split(')').length\n//     const openParensBefore = nlBefore.split('(').length - closeParensBefore\n//     let cleanAfter = nlAfter\n//     for (let i = 0; i < openParensBefore; i++) {\n//       cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n//     }\n//     nlAfter = cleanAfter\n//\n//     const dollar = nlAfter === '' ? '(?:$|\\\\/)' : ''\n//\n//     re = nlBefore + nlFirst + nlAfter + dollar + nlLast\n//   }\n//\n//   // if the re is not \"\" at this point, then we need to make sure\n//   // it doesn't match against an empty path part.\n//   // Otherwise a/* will match a/, which it should not.\n//   if (re !== '' && hasMagic) {\n//     re = '(?=.)' + re\n//   }\n//\n//   if (addPatternStart) {\n//     re = patternStart() + re\n//   }\n//\n//   // if it's nocase, and the lcase/uppercase don't match, it's magic\n//   if (options.nocase && !hasMagic && !options.nocaseMagicOnly) {\n//     hasMagic = pattern.toUpperCase() !== pattern.toLowerCase()\n//   }\n//\n//   // skip the regexp for non-magical patterns\n//   // unescape anything in it, though, so that it'll be\n//   // an exact match against a file etc.\n//   if (!hasMagic) {\n//     return globUnescape(re)\n//   }\n//\n//   return re\n// }\n"]}